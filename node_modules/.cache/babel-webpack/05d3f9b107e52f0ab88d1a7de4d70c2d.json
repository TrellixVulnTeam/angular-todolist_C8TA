{"ast":null,"code":"'use strict';\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  (function (global) {\n    var OriginalDate = global.Date; // Since when we compile this file to `es2015`, and if we define\n    // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n    // there will be an error which is `Cannot assign to read only property 'prototype'`\n    // so we need to use function implementation here.\n\n    function FakeDate() {\n      if (arguments.length === 0) {\n        var d = new OriginalDate();\n        d.setTime(FakeDate.now());\n        return d;\n      } else {\n        var args = Array.prototype.slice.call(arguments);\n        return new (OriginalDate.bind.apply(OriginalDate, __spreadArrays([void 0], args)))();\n      }\n    }\n\n    FakeDate.now = function () {\n      var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n      if (fakeAsyncTestZoneSpec) {\n        return fakeAsyncTestZoneSpec.getFakeSystemTime();\n      }\n\n      return OriginalDate.now.apply(this, arguments);\n    };\n\n    FakeDate.UTC = OriginalDate.UTC;\n    FakeDate.parse = OriginalDate.parse; // keep a reference for zone patched timer function\n\n    var timers = {\n      setTimeout: global.setTimeout,\n      setInterval: global.setInterval,\n      clearTimeout: global.clearTimeout,\n      clearInterval: global.clearInterval\n    };\n\n    var Scheduler = function () {\n      function Scheduler() {\n        // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n        this._schedulerQueue = []; // Current simulated time in millis.\n\n        this._currentTickTime = 0; // Current fake system base time in millis.\n\n        this._currentFakeBaseSystemTime = OriginalDate.now(); // track requeuePeriodicTimer\n\n        this._currentTickRequeuePeriodicEntries = [];\n      }\n\n      Scheduler.prototype.getCurrentTickTime = function () {\n        return this._currentTickTime;\n      };\n\n      Scheduler.prototype.getFakeSystemTime = function () {\n        return this._currentFakeBaseSystemTime + this._currentTickTime;\n      };\n\n      Scheduler.prototype.setFakeBaseSystemTime = function (fakeBaseSystemTime) {\n        this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n      };\n\n      Scheduler.prototype.getRealSystemTime = function () {\n        return OriginalDate.now();\n      };\n\n      Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n        options = Object.assign({\n          args: [],\n          isPeriodic: false,\n          isRequestAnimationFrame: false,\n          id: -1,\n          isRequeuePeriodic: false\n        }, options);\n        var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n        var endTime = this._currentTickTime + delay; // Insert so that scheduler queue remains sorted by end time.\n\n        var newEntry = {\n          endTime: endTime,\n          id: currentId,\n          func: cb,\n          args: options.args,\n          delay: delay,\n          isPeriodic: options.isPeriodic,\n          isRequestAnimationFrame: options.isRequestAnimationFrame\n        };\n\n        if (options.isRequeuePeriodic) {\n          this._currentTickRequeuePeriodicEntries.push(newEntry);\n        }\n\n        var i = 0;\n\n        for (; i < this._schedulerQueue.length; i++) {\n          var currentEntry = this._schedulerQueue[i];\n\n          if (newEntry.endTime < currentEntry.endTime) {\n            break;\n          }\n        }\n\n        this._schedulerQueue.splice(i, 0, newEntry);\n\n        return currentId;\n      };\n\n      Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n        for (var i = 0; i < this._schedulerQueue.length; i++) {\n          if (this._schedulerQueue[i].id == id) {\n            this._schedulerQueue.splice(i, 1);\n\n            break;\n          }\n        }\n      };\n\n      Scheduler.prototype.removeAll = function () {\n        this._schedulerQueue = [];\n      };\n\n      Scheduler.prototype.getTimerCount = function () {\n        return this._schedulerQueue.length;\n      };\n\n      Scheduler.prototype.tickToNext = function (step, doTick, tickOptions) {\n        if (step === void 0) {\n          step = 1;\n        }\n\n        if (this._schedulerQueue.length < step) {\n          return;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var targetTask = this._schedulerQueue[step - 1];\n        this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n      };\n\n      Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        var finalTime = this._currentTickTime + millis;\n        var lastCurrentTime = 0;\n        tickOptions = Object.assign({\n          processNewMacroTasksSynchronously: true\n        }, tickOptions); // we need to copy the schedulerQueue so nested timeout\n        // will not be wrongly called in the current tick\n        // https://github.com/angular/angular/issues/33799\n\n        var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n\n        if (schedulerQueue.length === 0 && doTick) {\n          doTick(millis);\n          return;\n        }\n\n        while (schedulerQueue.length > 0) {\n          // clear requeueEntries before each loop\n          this._currentTickRequeuePeriodicEntries = [];\n          var current = schedulerQueue[0];\n\n          if (finalTime < current.endTime) {\n            // Done processing the queue since it's sorted by endTime.\n            break;\n          } else {\n            // Time to run scheduled function. Remove it from the head of queue.\n            var current_1 = schedulerQueue.shift();\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              var idx = this._schedulerQueue.indexOf(current_1);\n\n              if (idx >= 0) {\n                this._schedulerQueue.splice(idx, 1);\n              }\n            }\n\n            lastCurrentTime = this._currentTickTime;\n            this._currentTickTime = current_1.endTime;\n\n            if (doTick) {\n              doTick(this._currentTickTime - lastCurrentTime);\n            }\n\n            var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTickTime] : current_1.args);\n\n            if (!retval) {\n              // Uncaught exception in the current scheduled function. Stop processing the queue.\n              break;\n            } // check is there any requeue periodic entry is added in\n            // current loop, if there is, we need to add to current loop\n\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                var i = 0;\n\n                for (; i < schedulerQueue.length; i++) {\n                  var currentEntry = schedulerQueue[i];\n\n                  if (newEntry.endTime < currentEntry.endTime) {\n                    break;\n                  }\n                }\n\n                schedulerQueue.splice(i, 0, newEntry);\n              });\n            }\n          }\n        }\n\n        lastCurrentTime = this._currentTickTime;\n        this._currentTickTime = finalTime;\n\n        if (doTick) {\n          doTick(this._currentTickTime - lastCurrentTime);\n        }\n      };\n\n      Scheduler.prototype.flushOnlyPendingTimers = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick, {\n          processNewMacroTasksSynchronously: false\n        });\n        return this._currentTickTime - startTime;\n      };\n\n      Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n        if (limit === void 0) {\n          limit = 20;\n        }\n\n        if (flushPeriodic === void 0) {\n          flushPeriodic = false;\n        }\n\n        if (flushPeriodic) {\n          return this.flushPeriodic(doTick);\n        } else {\n          return this.flushNonPeriodic(limit, doTick);\n        }\n      };\n\n      Scheduler.prototype.flushPeriodic = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick);\n        return this._currentTickTime - startTime;\n      };\n\n      Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n        var startTime = this._currentTickTime;\n        var lastCurrentTime = 0;\n        var count = 0;\n\n        while (this._schedulerQueue.length > 0) {\n          count++;\n\n          if (count > limit) {\n            throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n          } // flush only non-periodic timers.\n          // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n\n\n          if (this._schedulerQueue.filter(function (task) {\n            return !task.isPeriodic && !task.isRequestAnimationFrame;\n          }).length === 0) {\n            break;\n          }\n\n          var current = this._schedulerQueue.shift();\n\n          lastCurrentTime = this._currentTickTime;\n          this._currentTickTime = current.endTime;\n\n          if (doTick) {\n            // Update any secondary schedulers like Jasmine mock Date.\n            doTick(this._currentTickTime - lastCurrentTime);\n          }\n\n          var retval = current.func.apply(global, current.args);\n\n          if (!retval) {\n            // Uncaught exception in the current scheduled function. Stop processing the queue.\n            break;\n          }\n        }\n\n        return this._currentTickTime - startTime;\n      };\n\n      return Scheduler;\n    }(); // Next scheduler id.\n\n\n    Scheduler.nextId = 1;\n\n    var FakeAsyncTestZoneSpec = function () {\n      function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n        if (trackPendingRequestAnimationFrame === void 0) {\n          trackPendingRequestAnimationFrame = false;\n        }\n\n        this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n        this.macroTaskOptions = macroTaskOptions;\n        this._scheduler = new Scheduler();\n        this._microtasks = [];\n        this._lastError = null;\n        this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n        this.patchDateLocked = false;\n        this.properties = {\n          'FakeAsyncTestZoneSpec': this\n        };\n        this.name = 'fakeAsyncTestZone for ' + namePrefix; // in case user can't access the construction of FakeAsyncTestSpec\n        // user can also define macroTaskOptions by define a global variable.\n\n        if (!this.macroTaskOptions) {\n          this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n        }\n      }\n\n      FakeAsyncTestZoneSpec.assertInZone = function () {\n        if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n        var _this = this;\n\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          fn.apply(global, args);\n\n          if (_this._lastError === null) {\n            // Success\n            if (completers.onSuccess != null) {\n              completers.onSuccess.apply(global);\n            } // Flush microtasks only on success.\n\n\n            _this.flushMicrotasks();\n          } else {\n            // Failure\n            if (completers.onError != null) {\n              completers.onError.apply(global);\n            }\n          } // Return true if there were no errors, false otherwise.\n\n\n          return _this._lastError === null;\n        };\n      };\n\n      FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n        var index = timers.indexOf(id);\n\n        if (index > -1) {\n          timers.splice(index, 1);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n        var _this = this;\n\n        return function () {\n          // Requeue the timer callback if it's not been canceled.\n          if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n            _this._scheduler.scheduleFunction(fn, interval, {\n              args: args,\n              isPeriodic: true,\n              id: id,\n              isRequeuePeriodic: true\n            });\n          }\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n        if (isTimer === void 0) {\n          isTimer = true;\n        }\n\n        var removeTimerFn = this._dequeueTimer(Scheduler.nextId); // Queue the callback and dequeue the timer on success and error.\n\n\n        var cb = this._fnAndFlush(fn, {\n          onSuccess: removeTimerFn,\n          onError: removeTimerFn\n        });\n\n        var id = this._scheduler.scheduleFunction(cb, delay, {\n          args: args,\n          isRequestAnimationFrame: !isTimer\n        });\n\n        if (isTimer) {\n          this.pendingTimers.push(id);\n        }\n\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n        var id = Scheduler.nextId;\n        var completers = {\n          onSuccess: null,\n          onError: this._dequeuePeriodicTimer(id)\n        };\n\n        var cb = this._fnAndFlush(fn, completers); // Use the callback created above to requeue on success.\n\n\n        completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id); // Queue the callback and dequeue the periodic timer only on error.\n\n        this._scheduler.scheduleFunction(cb, interval, {\n          args: args,\n          isPeriodic: true\n        });\n\n        this.pendingPeriodicTimers.push(id);\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n        var error = this._lastError || this._uncaughtPromiseErrors[0];\n        this._uncaughtPromiseErrors.length = 0;\n        this._lastError = null;\n        throw error;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getCurrentTickTime = function () {\n        return this._scheduler.getCurrentTickTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getFakeSystemTime = function () {\n        return this._scheduler.getFakeSystemTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.setFakeBaseSystemTime = function (realTime) {\n        this._scheduler.setFakeBaseSystemTime(realTime);\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getRealSystemTime = function () {\n        return this._scheduler.getRealSystemTime();\n      };\n\n      FakeAsyncTestZoneSpec.patchDate = function () {\n        if (!!global[Zone.__symbol__('disableDatePatching')]) {\n          // we don't want to patch global Date\n          // because in some case, global Date\n          // is already being patched, we need to provide\n          // an option to let user still use their\n          // own version of Date.\n          return;\n        }\n\n        if (global['Date'] === FakeDate) {\n          // already patched\n          return;\n        }\n\n        global['Date'] = FakeDate;\n        FakeDate.prototype = OriginalDate.prototype; // try check and reset timers\n        // because jasmine.clock().install() may\n        // have replaced the global timer\n\n        FakeAsyncTestZoneSpec.checkTimerPatch();\n      };\n\n      FakeAsyncTestZoneSpec.resetDate = function () {\n        if (global['Date'] === FakeDate) {\n          global['Date'] = OriginalDate;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n        if (global.setTimeout !== timers.setTimeout) {\n          global.setTimeout = timers.setTimeout;\n          global.clearTimeout = timers.clearTimeout;\n        }\n\n        if (global.setInterval !== timers.setInterval) {\n          global.setInterval = timers.setInterval;\n          global.clearInterval = timers.clearInterval;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n        this.patchDateLocked = true;\n        FakeAsyncTestZoneSpec.patchDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n        this.patchDateLocked = false;\n        FakeAsyncTestZoneSpec.resetDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.tickToNext = function (steps, doTick, tickOptions) {\n        if (steps === void 0) {\n          steps = 1;\n        }\n\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n\n        if (steps <= 0) {\n          return;\n        }\n\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tickToNext(steps, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tick(millis, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n        var _this = this;\n\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        var flushErrors = function () {\n          if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n            // If there is an error stop processing the microtask queue and rethrow the error.\n            _this._resetLastErrorAndThrow();\n          }\n        };\n\n        while (this._microtasks.length > 0) {\n          var microtask = this._microtasks.shift();\n\n          microtask.func.apply(microtask.target, microtask.args);\n        }\n\n        flushErrors();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flushOnlyPendingTimers = function (doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.removeAllTimers = function () {\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        this._scheduler.removeAll();\n\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getTimerCount = function () {\n        return this._scheduler.getTimerCount() + this._microtasks.length;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        switch (task.type) {\n          case 'microTask':\n            var args = task.data && task.data.args; // should pass additional arguments to callback if have any\n            // currently we know process.nextTick will have such additional\n            // arguments\n\n            var additionalArgs = void 0;\n\n            if (args) {\n              var callbackIndex = task.data.cbIdx;\n\n              if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n              }\n            }\n\n            this._microtasks.push({\n              func: task.invoke,\n              args: additionalArgs,\n              target: task.data && task.data.target\n            });\n\n            break;\n\n          case 'macroTask':\n            switch (task.source) {\n              case 'setTimeout':\n                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'setImmediate':\n                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                break;\n\n              case 'setInterval':\n                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'XMLHttpRequest.send':\n                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n\n              case 'requestAnimationFrame':\n              case 'webkitRequestAnimationFrame':\n              case 'mozRequestAnimationFrame':\n                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                // (60 frames per second)\n                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                break;\n\n              default:\n                // user can define which macroTask they want to support by passing\n                // macroTaskOptions\n                var macroTaskOption = this.findMacroTaskOption(task);\n\n                if (macroTaskOption) {\n                  var args_1 = task.data && task.data['args'];\n                  var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                  var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n\n                  if (!!macroTaskOption.isPeriodic) {\n                    // periodic macroTask, use setInterval to simulate\n                    task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                    task.data.isPeriodic = true;\n                  } else {\n                    // not periodic, use setTimeout to simulate\n                    task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                  }\n\n                  break;\n                }\n\n                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n            }\n\n            break;\n\n          case 'eventTask':\n            task = delegate.scheduleTask(target, task);\n            break;\n        }\n\n        return task;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        switch (task.source) {\n          case 'setTimeout':\n          case 'requestAnimationFrame':\n          case 'webkitRequestAnimationFrame':\n          case 'mozRequestAnimationFrame':\n            return this._clearTimeout(task.data['handleId']);\n\n          case 'setInterval':\n            return this._clearInterval(task.data['handleId']);\n\n          default:\n            // user can define which macroTask they want to support by passing\n            // macroTaskOptions\n            var macroTaskOption = this.findMacroTaskOption(task);\n\n            if (macroTaskOption) {\n              var handleId = task.data['handleId'];\n              return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n            }\n\n            return delegate.cancelTask(target, task);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n        try {\n          FakeAsyncTestZoneSpec.patchDate();\n          return delegate.invoke(target, callback, applyThis, applyArgs, source);\n        } finally {\n          if (!this.patchDateLocked) {\n            FakeAsyncTestZoneSpec.resetDate();\n          }\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n        if (!this.macroTaskOptions) {\n          return null;\n        }\n\n        for (var i = 0; i < this.macroTaskOptions.length; i++) {\n          var macroTaskOption = this.macroTaskOptions[i];\n\n          if (macroTaskOption.source === task.source) {\n            return macroTaskOption;\n          }\n        }\n\n        return null;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        this._lastError = error;\n        return false; // Don't propagate error to parent zone.\n      };\n\n      return FakeAsyncTestZoneSpec;\n    }(); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n\n    Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n  })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n\n  Zone.__load_patch('fakeasync', function (global, Zone, api) {\n    var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n\n    function getProxyZoneSpec() {\n      return Zone && Zone['ProxyZoneSpec'];\n    }\n\n    var _fakeAsyncTestZoneSpec = null;\n    /**\n     * Clears out the shared fake async zone for a test.\n     * To be called in a global `beforeEach`.\n     *\n     * @experimental\n     */\n\n    function resetFakeAsyncZone() {\n      if (_fakeAsyncTestZoneSpec) {\n        _fakeAsyncTestZoneSpec.unlockDatePatch();\n      }\n\n      _fakeAsyncTestZoneSpec = null; // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n\n      getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n    }\n    /**\n     * Wraps a function to be executed in the fakeAsync zone:\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n     *\n     * If there are any pending timers at the end of the function, an exception will be thrown.\n     *\n     * Can be used to wrap inject() calls.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @param fn\n     * @returns The function wrapped to be executed in the fakeAsync zone\n     *\n     * @experimental\n     */\n\n\n    function fakeAsync(fn) {\n      // Not using an arrow function to preserve context passed from call site\n      var fakeAsyncFn = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var ProxyZoneSpec = getProxyZoneSpec();\n\n        if (!ProxyZoneSpec) {\n          throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/proxy.js');\n        }\n\n        var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n\n        if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n          throw new Error('fakeAsync() calls can not be nested');\n        }\n\n        try {\n          // in case jasmine.clock init a fakeAsyncTestZoneSpec\n          if (!_fakeAsyncTestZoneSpec) {\n            if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n              throw new Error('fakeAsync() calls can not be nested');\n            }\n\n            _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n          }\n\n          var res = void 0;\n          var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n          proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n\n          _fakeAsyncTestZoneSpec.lockDatePatch();\n\n          try {\n            res = fn.apply(this, args);\n            flushMicrotasks();\n          } finally {\n            proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n            throw new Error(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \" + \"periodic timer(s) still in the queue.\");\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n            throw new Error(_fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\n          }\n\n          return res;\n        } finally {\n          resetFakeAsyncZone();\n        }\n      };\n\n      fakeAsyncFn.isFakeAsync = true;\n      return fakeAsyncFn;\n    }\n\n    function _getFakeAsyncZoneSpec() {\n      if (_fakeAsyncTestZoneSpec == null) {\n        _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (_fakeAsyncTestZoneSpec == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      }\n\n      return _fakeAsyncTestZoneSpec;\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n     *\n     * The microtasks queue is drained at the very start of this function and after any timer callback\n     * has been executed.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @experimental\n     */\n\n\n    function tick(millis, ignoreNestedTimeout) {\n      if (millis === void 0) {\n        millis = 0;\n      }\n\n      if (ignoreNestedTimeout === void 0) {\n        ignoreNestedTimeout = false;\n      }\n\n      _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\n     * of time that would have been elapsed.\n     *\n     * @param maxTurns\n     * @returns The simulated time elapsed, in millis.\n     *\n     * @experimental\n     */\n\n\n    function flush(maxTurns) {\n      return _getFakeAsyncZoneSpec().flush(maxTurns);\n    }\n    /**\n     * Discard all remaining periodic tasks.\n     *\n     * @experimental\n     */\n\n\n    function discardPeriodicTasks() {\n      var zoneSpec = _getFakeAsyncZoneSpec();\n\n      var pendingTimers = zoneSpec.pendingPeriodicTimers;\n      zoneSpec.pendingPeriodicTimers.length = 0;\n    }\n    /**\n     * Flush any pending microtasks.\n     *\n     * @experimental\n     */\n\n\n    function flushMicrotasks() {\n      _getFakeAsyncZoneSpec().flushMicrotasks();\n    }\n\n    Zone[api.symbol('fakeAsyncTest')] = {\n      resetFakeAsyncZone: resetFakeAsyncZone,\n      flushMicrotasks: flushMicrotasks,\n      discardPeriodicTasks: discardPeriodicTasks,\n      tick: tick,\n      flush: flush,\n      fakeAsync: fakeAsync\n    };\n  }, true);\n});","map":{"version":3,"sources":["D:/angular-material-todo/node_modules/zone.js/dist/fake-async-test.js"],"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","factory","define","amd","global","OriginalDate","Date","FakeDate","d","setTime","now","args","prototype","slice","call","bind","apply","fakeAsyncTestZoneSpec","Zone","current","get","getFakeSystemTime","UTC","parse","timers","setTimeout","setInterval","clearTimeout","clearInterval","Scheduler","_schedulerQueue","_currentTickTime","_currentFakeBaseSystemTime","_currentTickRequeuePeriodicEntries","getCurrentTickTime","setFakeBaseSystemTime","fakeBaseSystemTime","getRealSystemTime","scheduleFunction","cb","delay","options","Object","assign","isPeriodic","isRequestAnimationFrame","id","isRequeuePeriodic","currentId","nextId","endTime","newEntry","func","push","currentEntry","splice","removeScheduledFunctionWithId","removeAll","getTimerCount","tickToNext","step","doTick","tickOptions","startTime","targetTask","tick","millis","finalTime","lastCurrentTime","processNewMacroTasksSynchronously","schedulerQueue","current_1","shift","idx","indexOf","retval","forEach","flushOnlyPendingTimers","lastTask","flush","limit","flushPeriodic","flushNonPeriodic","count","Error","filter","task","FakeAsyncTestZoneSpec","namePrefix","trackPendingRequestAnimationFrame","macroTaskOptions","_scheduler","_microtasks","_lastError","_uncaughtPromiseErrors","Promise","__symbol__","pendingPeriodicTimers","pendingTimers","patchDateLocked","properties","name","assertInZone","_fnAndFlush","fn","completers","_this","_i","onSuccess","flushMicrotasks","onError","_removeTimer","index","_dequeueTimer","_requeuePeriodicTimer","interval","_dequeuePeriodicTimer","_setTimeout","isTimer","removeTimerFn","_clearTimeout","_setInterval","_clearInterval","_resetLastErrorAndThrow","error","realTime","patchDate","checkTimerPatch","resetDate","lockDatePatch","unlockDatePatch","steps","flushErrors","microtask","target","elapsed","removeAllTimers","onScheduleTask","delegate","type","data","additionalArgs","callbackIndex","cbIdx","invoke","source","macroTaskOption","findMacroTaskOption","args_1","callbackArgs","scheduleTask","onCancelTask","handleId","cancelTask","onInvoke","callback","applyThis","applyArgs","onHandleError","parentZoneDelegate","currentZone","targetZone","window","self","__load_patch","api","getProxyZoneSpec","_fakeAsyncTestZoneSpec","resetFakeAsyncZone","assertPresent","resetDelegate","fakeAsync","fakeAsyncFn","ProxyZoneSpec","proxyZoneSpec","getDelegate","res","lastProxyZoneSpec","setDelegate","isFakeAsync","_getFakeAsyncZoneSpec","ignoreNestedTimeout","maxTurns","discardPeriodicTasks","zoneSpec","symbol"],"mappings":"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","sourcesContent":["'use strict';\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n        factory();\n}((function () {\n    'use strict';\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (global) {\n        var OriginalDate = global.Date;\n        // Since when we compile this file to `es2015`, and if we define\n        // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n        // there will be an error which is `Cannot assign to read only property 'prototype'`\n        // so we need to use function implementation here.\n        function FakeDate() {\n            if (arguments.length === 0) {\n                var d = new OriginalDate();\n                d.setTime(FakeDate.now());\n                return d;\n            }\n            else {\n                var args = Array.prototype.slice.call(arguments);\n                return new (OriginalDate.bind.apply(OriginalDate, __spreadArrays([void 0], args)))();\n            }\n        }\n        FakeDate.now = function () {\n            var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n            if (fakeAsyncTestZoneSpec) {\n                return fakeAsyncTestZoneSpec.getFakeSystemTime();\n            }\n            return OriginalDate.now.apply(this, arguments);\n        };\n        FakeDate.UTC = OriginalDate.UTC;\n        FakeDate.parse = OriginalDate.parse;\n        // keep a reference for zone patched timer function\n        var timers = {\n            setTimeout: global.setTimeout,\n            setInterval: global.setInterval,\n            clearTimeout: global.clearTimeout,\n            clearInterval: global.clearInterval\n        };\n        var Scheduler = /** @class */ (function () {\n            function Scheduler() {\n                // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n                this._schedulerQueue = [];\n                // Current simulated time in millis.\n                this._currentTickTime = 0;\n                // Current fake system base time in millis.\n                this._currentFakeBaseSystemTime = OriginalDate.now();\n                // track requeuePeriodicTimer\n                this._currentTickRequeuePeriodicEntries = [];\n            }\n            Scheduler.prototype.getCurrentTickTime = function () {\n                return this._currentTickTime;\n            };\n            Scheduler.prototype.getFakeSystemTime = function () {\n                return this._currentFakeBaseSystemTime + this._currentTickTime;\n            };\n            Scheduler.prototype.setFakeBaseSystemTime = function (fakeBaseSystemTime) {\n                this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n            };\n            Scheduler.prototype.getRealSystemTime = function () {\n                return OriginalDate.now();\n            };\n            Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n                options = Object.assign({\n                    args: [],\n                    isPeriodic: false,\n                    isRequestAnimationFrame: false,\n                    id: -1,\n                    isRequeuePeriodic: false\n                }, options);\n                var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n                var endTime = this._currentTickTime + delay;\n                // Insert so that scheduler queue remains sorted by end time.\n                var newEntry = {\n                    endTime: endTime,\n                    id: currentId,\n                    func: cb,\n                    args: options.args,\n                    delay: delay,\n                    isPeriodic: options.isPeriodic,\n                    isRequestAnimationFrame: options.isRequestAnimationFrame\n                };\n                if (options.isRequeuePeriodic) {\n                    this._currentTickRequeuePeriodicEntries.push(newEntry);\n                }\n                var i = 0;\n                for (; i < this._schedulerQueue.length; i++) {\n                    var currentEntry = this._schedulerQueue[i];\n                    if (newEntry.endTime < currentEntry.endTime) {\n                        break;\n                    }\n                }\n                this._schedulerQueue.splice(i, 0, newEntry);\n                return currentId;\n            };\n            Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n                for (var i = 0; i < this._schedulerQueue.length; i++) {\n                    if (this._schedulerQueue[i].id == id) {\n                        this._schedulerQueue.splice(i, 1);\n                        break;\n                    }\n                }\n            };\n            Scheduler.prototype.removeAll = function () {\n                this._schedulerQueue = [];\n            };\n            Scheduler.prototype.getTimerCount = function () {\n                return this._schedulerQueue.length;\n            };\n            Scheduler.prototype.tickToNext = function (step, doTick, tickOptions) {\n                if (step === void 0) { step = 1; }\n                if (this._schedulerQueue.length < step) {\n                    return;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var targetTask = this._schedulerQueue[step - 1];\n                this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n            };\n            Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                var finalTime = this._currentTickTime + millis;\n                var lastCurrentTime = 0;\n                tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);\n                // we need to copy the schedulerQueue so nested timeout\n                // will not be wrongly called in the current tick\n                // https://github.com/angular/angular/issues/33799\n                var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ?\n                    this._schedulerQueue :\n                    this._schedulerQueue.slice();\n                if (schedulerQueue.length === 0 && doTick) {\n                    doTick(millis);\n                    return;\n                }\n                while (schedulerQueue.length > 0) {\n                    // clear requeueEntries before each loop\n                    this._currentTickRequeuePeriodicEntries = [];\n                    var current = schedulerQueue[0];\n                    if (finalTime < current.endTime) {\n                        // Done processing the queue since it's sorted by endTime.\n                        break;\n                    }\n                    else {\n                        // Time to run scheduled function. Remove it from the head of queue.\n                        var current_1 = schedulerQueue.shift();\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            var idx = this._schedulerQueue.indexOf(current_1);\n                            if (idx >= 0) {\n                                this._schedulerQueue.splice(idx, 1);\n                            }\n                        }\n                        lastCurrentTime = this._currentTickTime;\n                        this._currentTickTime = current_1.endTime;\n                        if (doTick) {\n                            doTick(this._currentTickTime - lastCurrentTime);\n                        }\n                        var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTickTime] : current_1.args);\n                        if (!retval) {\n                            // Uncaught exception in the current scheduled function. Stop processing the queue.\n                            break;\n                        }\n                        // check is there any requeue periodic entry is added in\n                        // current loop, if there is, we need to add to current loop\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                                var i = 0;\n                                for (; i < schedulerQueue.length; i++) {\n                                    var currentEntry = schedulerQueue[i];\n                                    if (newEntry.endTime < currentEntry.endTime) {\n                                        break;\n                                    }\n                                }\n                                schedulerQueue.splice(i, 0, newEntry);\n                            });\n                        }\n                    }\n                }\n                lastCurrentTime = this._currentTickTime;\n                this._currentTickTime = finalTime;\n                if (doTick) {\n                    doTick(this._currentTickTime - lastCurrentTime);\n                }\n            };\n            Scheduler.prototype.flushOnlyPendingTimers = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick, { processNewMacroTasksSynchronously: false });\n                return this._currentTickTime - startTime;\n            };\n            Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n                if (limit === void 0) { limit = 20; }\n                if (flushPeriodic === void 0) { flushPeriodic = false; }\n                if (flushPeriodic) {\n                    return this.flushPeriodic(doTick);\n                }\n                else {\n                    return this.flushNonPeriodic(limit, doTick);\n                }\n            };\n            Scheduler.prototype.flushPeriodic = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick);\n                return this._currentTickTime - startTime;\n            };\n            Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n                var startTime = this._currentTickTime;\n                var lastCurrentTime = 0;\n                var count = 0;\n                while (this._schedulerQueue.length > 0) {\n                    count++;\n                    if (count > limit) {\n                        throw new Error('flush failed after reaching the limit of ' + limit +\n                            ' tasks. Does your code use a polling timeout?');\n                    }\n                    // flush only non-periodic timers.\n                    // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n                    if (this._schedulerQueue.filter(function (task) { return !task.isPeriodic && !task.isRequestAnimationFrame; })\n                        .length === 0) {\n                        break;\n                    }\n                    var current = this._schedulerQueue.shift();\n                    lastCurrentTime = this._currentTickTime;\n                    this._currentTickTime = current.endTime;\n                    if (doTick) {\n                        // Update any secondary schedulers like Jasmine mock Date.\n                        doTick(this._currentTickTime - lastCurrentTime);\n                    }\n                    var retval = current.func.apply(global, current.args);\n                    if (!retval) {\n                        // Uncaught exception in the current scheduled function. Stop processing the queue.\n                        break;\n                    }\n                }\n                return this._currentTickTime - startTime;\n            };\n            return Scheduler;\n        }());\n        // Next scheduler id.\n        Scheduler.nextId = 1;\n        var FakeAsyncTestZoneSpec = /** @class */ (function () {\n            function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n                if (trackPendingRequestAnimationFrame === void 0) { trackPendingRequestAnimationFrame = false; }\n                this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n                this.macroTaskOptions = macroTaskOptions;\n                this._scheduler = new Scheduler();\n                this._microtasks = [];\n                this._lastError = null;\n                this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n                this.patchDateLocked = false;\n                this.properties = { 'FakeAsyncTestZoneSpec': this };\n                this.name = 'fakeAsyncTestZone for ' + namePrefix;\n                // in case user can't access the construction of FakeAsyncTestSpec\n                // user can also define macroTaskOptions by define a global variable.\n                if (!this.macroTaskOptions) {\n                    this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n                }\n            }\n            FakeAsyncTestZoneSpec.assertInZone = function () {\n                if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n                var _this = this;\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    fn.apply(global, args);\n                    if (_this._lastError === null) { // Success\n                        if (completers.onSuccess != null) {\n                            completers.onSuccess.apply(global);\n                        }\n                        // Flush microtasks only on success.\n                        _this.flushMicrotasks();\n                    }\n                    else { // Failure\n                        if (completers.onError != null) {\n                            completers.onError.apply(global);\n                        }\n                    }\n                    // Return true if there were no errors, false otherwise.\n                    return _this._lastError === null;\n                };\n            };\n            FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n                var index = timers.indexOf(id);\n                if (index > -1) {\n                    timers.splice(index, 1);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n                var _this = this;\n                return function () {\n                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n                var _this = this;\n                return function () {\n                    // Requeue the timer callback if it's not been canceled.\n                    if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n                        _this._scheduler.scheduleFunction(fn, interval, { args: args, isPeriodic: true, id: id, isRequeuePeriodic: true });\n                    }\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n                var _this = this;\n                return function () {\n                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n                if (isTimer === void 0) { isTimer = true; }\n                var removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n                // Queue the callback and dequeue the timer on success and error.\n                var cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });\n                var id = this._scheduler.scheduleFunction(cb, delay, { args: args, isRequestAnimationFrame: !isTimer });\n                if (isTimer) {\n                    this.pendingTimers.push(id);\n                }\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n                var id = Scheduler.nextId;\n                var completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };\n                var cb = this._fnAndFlush(fn, completers);\n                // Use the callback created above to requeue on success.\n                completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n                // Queue the callback and dequeue the periodic timer only on error.\n                this._scheduler.scheduleFunction(cb, interval, { args: args, isPeriodic: true });\n                this.pendingPeriodicTimers.push(id);\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n                var error = this._lastError || this._uncaughtPromiseErrors[0];\n                this._uncaughtPromiseErrors.length = 0;\n                this._lastError = null;\n                throw error;\n            };\n            FakeAsyncTestZoneSpec.prototype.getCurrentTickTime = function () {\n                return this._scheduler.getCurrentTickTime();\n            };\n            FakeAsyncTestZoneSpec.prototype.getFakeSystemTime = function () {\n                return this._scheduler.getFakeSystemTime();\n            };\n            FakeAsyncTestZoneSpec.prototype.setFakeBaseSystemTime = function (realTime) {\n                this._scheduler.setFakeBaseSystemTime(realTime);\n            };\n            FakeAsyncTestZoneSpec.prototype.getRealSystemTime = function () {\n                return this._scheduler.getRealSystemTime();\n            };\n            FakeAsyncTestZoneSpec.patchDate = function () {\n                if (!!global[Zone.__symbol__('disableDatePatching')]) {\n                    // we don't want to patch global Date\n                    // because in some case, global Date\n                    // is already being patched, we need to provide\n                    // an option to let user still use their\n                    // own version of Date.\n                    return;\n                }\n                if (global['Date'] === FakeDate) {\n                    // already patched\n                    return;\n                }\n                global['Date'] = FakeDate;\n                FakeDate.prototype = OriginalDate.prototype;\n                // try check and reset timers\n                // because jasmine.clock().install() may\n                // have replaced the global timer\n                FakeAsyncTestZoneSpec.checkTimerPatch();\n            };\n            FakeAsyncTestZoneSpec.resetDate = function () {\n                if (global['Date'] === FakeDate) {\n                    global['Date'] = OriginalDate;\n                }\n            };\n            FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n                if (global.setTimeout !== timers.setTimeout) {\n                    global.setTimeout = timers.setTimeout;\n                    global.clearTimeout = timers.clearTimeout;\n                }\n                if (global.setInterval !== timers.setInterval) {\n                    global.setInterval = timers.setInterval;\n                    global.clearInterval = timers.clearInterval;\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n                this.patchDateLocked = true;\n                FakeAsyncTestZoneSpec.patchDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n                this.patchDateLocked = false;\n                FakeAsyncTestZoneSpec.resetDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.tickToNext = function (steps, doTick, tickOptions) {\n                if (steps === void 0) { steps = 1; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                if (steps <= 0) {\n                    return;\n                }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tickToNext(steps, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tick(millis, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n                var _this = this;\n                FakeAsyncTestZoneSpec.assertInZone();\n                var flushErrors = function () {\n                    if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n                        // If there is an error stop processing the microtask queue and rethrow the error.\n                        _this._resetLastErrorAndThrow();\n                    }\n                };\n                while (this._microtasks.length > 0) {\n                    var microtask = this._microtasks.shift();\n                    microtask.func.apply(microtask.target, microtask.args);\n                }\n                flushErrors();\n            };\n            FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.flushOnlyPendingTimers = function (doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.removeAllTimers = function () {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this._scheduler.removeAll();\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n            };\n            FakeAsyncTestZoneSpec.prototype.getTimerCount = function () {\n                return this._scheduler.getTimerCount() + this._microtasks.length;\n            };\n            FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                switch (task.type) {\n                    case 'microTask':\n                        var args = task.data && task.data.args;\n                        // should pass additional arguments to callback if have any\n                        // currently we know process.nextTick will have such additional\n                        // arguments\n                        var additionalArgs = void 0;\n                        if (args) {\n                            var callbackIndex = task.data.cbIdx;\n                            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                            }\n                        }\n                        this._microtasks.push({\n                            func: task.invoke,\n                            args: additionalArgs,\n                            target: task.data && task.data.target\n                        });\n                        break;\n                    case 'macroTask':\n                        switch (task.source) {\n                            case 'setTimeout':\n                                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'setImmediate':\n                                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                                break;\n                            case 'setInterval':\n                                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'XMLHttpRequest.send':\n                                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +\n                                    task.data['url']);\n                            case 'requestAnimationFrame':\n                            case 'webkitRequestAnimationFrame':\n                            case 'mozRequestAnimationFrame':\n                                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                                // (60 frames per second)\n                                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                                break;\n                            default:\n                                // user can define which macroTask they want to support by passing\n                                // macroTaskOptions\n                                var macroTaskOption = this.findMacroTaskOption(task);\n                                if (macroTaskOption) {\n                                    var args_1 = task.data && task.data['args'];\n                                    var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                                    var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n                                    if (!!macroTaskOption.isPeriodic) {\n                                        // periodic macroTask, use setInterval to simulate\n                                        task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                                        task.data.isPeriodic = true;\n                                    }\n                                    else {\n                                        // not periodic, use setTimeout to simulate\n                                        task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                                    }\n                                    break;\n                                }\n                                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n                        }\n                        break;\n                    case 'eventTask':\n                        task = delegate.scheduleTask(target, task);\n                        break;\n                }\n                return task;\n            };\n            FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                switch (task.source) {\n                    case 'setTimeout':\n                    case 'requestAnimationFrame':\n                    case 'webkitRequestAnimationFrame':\n                    case 'mozRequestAnimationFrame':\n                        return this._clearTimeout(task.data['handleId']);\n                    case 'setInterval':\n                        return this._clearInterval(task.data['handleId']);\n                    default:\n                        // user can define which macroTask they want to support by passing\n                        // macroTaskOptions\n                        var macroTaskOption = this.findMacroTaskOption(task);\n                        if (macroTaskOption) {\n                            var handleId = task.data['handleId'];\n                            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) :\n                                this._clearTimeout(handleId);\n                        }\n                        return delegate.cancelTask(target, task);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n                try {\n                    FakeAsyncTestZoneSpec.patchDate();\n                    return delegate.invoke(target, callback, applyThis, applyArgs, source);\n                }\n                finally {\n                    if (!this.patchDateLocked) {\n                        FakeAsyncTestZoneSpec.resetDate();\n                    }\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n                if (!this.macroTaskOptions) {\n                    return null;\n                }\n                for (var i = 0; i < this.macroTaskOptions.length; i++) {\n                    var macroTaskOption = this.macroTaskOptions[i];\n                    if (macroTaskOption.source === task.source) {\n                        return macroTaskOption;\n                    }\n                }\n                return null;\n            };\n            FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                this._lastError = error;\n                return false; // Don't propagate error to parent zone.\n            };\n            return FakeAsyncTestZoneSpec;\n        }());\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n    })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n    Zone.__load_patch('fakeasync', function (global, Zone, api) {\n        var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n        function getProxyZoneSpec() {\n            return Zone && Zone['ProxyZoneSpec'];\n        }\n        var _fakeAsyncTestZoneSpec = null;\n        /**\n         * Clears out the shared fake async zone for a test.\n         * To be called in a global `beforeEach`.\n         *\n         * @experimental\n         */\n        function resetFakeAsyncZone() {\n            if (_fakeAsyncTestZoneSpec) {\n                _fakeAsyncTestZoneSpec.unlockDatePatch();\n            }\n            _fakeAsyncTestZoneSpec = null;\n            // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n            getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n        }\n        /**\n         * Wraps a function to be executed in the fakeAsync zone:\n         * - microtasks are manually executed by calling `flushMicrotasks()`,\n         * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n         *\n         * If there are any pending timers at the end of the function, an exception will be thrown.\n         *\n         * Can be used to wrap inject() calls.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @param fn\n         * @returns The function wrapped to be executed in the fakeAsync zone\n         *\n         * @experimental\n         */\n        function fakeAsync(fn) {\n            // Not using an arrow function to preserve context passed from call site\n            var fakeAsyncFn = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var ProxyZoneSpec = getProxyZoneSpec();\n                if (!ProxyZoneSpec) {\n                    throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                        'Please make sure that your environment includes zone.js/dist/proxy.js');\n                }\n                var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n                if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                try {\n                    // in case jasmine.clock init a fakeAsyncTestZoneSpec\n                    if (!_fakeAsyncTestZoneSpec) {\n                        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                            throw new Error('fakeAsync() calls can not be nested');\n                        }\n                        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n                    }\n                    var res = void 0;\n                    var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n                    proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n                    _fakeAsyncTestZoneSpec.lockDatePatch();\n                    try {\n                        res = fn.apply(this, args);\n                        flushMicrotasks();\n                    }\n                    finally {\n                        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                        throw new Error(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \" +\n                            \"periodic timer(s) still in the queue.\");\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                        throw new Error(_fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\n                    }\n                    return res;\n                }\n                finally {\n                    resetFakeAsyncZone();\n                }\n            };\n            fakeAsyncFn.isFakeAsync = true;\n            return fakeAsyncFn;\n        }\n        function _getFakeAsyncZoneSpec() {\n            if (_fakeAsyncTestZoneSpec == null) {\n                _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (_fakeAsyncTestZoneSpec == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            }\n            return _fakeAsyncTestZoneSpec;\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n         *\n         * The microtasks queue is drained at the very start of this function and after any timer callback\n         * has been executed.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @experimental\n         */\n        function tick(millis, ignoreNestedTimeout) {\n            if (millis === void 0) { millis = 0; }\n            if (ignoreNestedTimeout === void 0) { ignoreNestedTimeout = false; }\n            _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n         * draining the macrotask queue until it is empty. The returned value is the milliseconds\n         * of time that would have been elapsed.\n         *\n         * @param maxTurns\n         * @returns The simulated time elapsed, in millis.\n         *\n         * @experimental\n         */\n        function flush(maxTurns) {\n            return _getFakeAsyncZoneSpec().flush(maxTurns);\n        }\n        /**\n         * Discard all remaining periodic tasks.\n         *\n         * @experimental\n         */\n        function discardPeriodicTasks() {\n            var zoneSpec = _getFakeAsyncZoneSpec();\n            var pendingTimers = zoneSpec.pendingPeriodicTimers;\n            zoneSpec.pendingPeriodicTimers.length = 0;\n        }\n        /**\n         * Flush any pending microtasks.\n         *\n         * @experimental\n         */\n        function flushMicrotasks() {\n            _getFakeAsyncZoneSpec().flushMicrotasks();\n        }\n        Zone[api.symbol('fakeAsyncTest')] =\n            { resetFakeAsyncZone: resetFakeAsyncZone, flushMicrotasks: flushMicrotasks, discardPeriodicTasks: discardPeriodicTasks, tick: tick, flush: flush, fakeAsync: fakeAsync };\n    }, true);\n})));\n"]},"metadata":{},"sourceType":"script"}